<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Blog · BAWJ</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="BAWJ logo"/></a><div class="docs-package-name"><span class="docs-autofit">BAWJ</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Business Applications with Julia</a></li><li class="is-active"><a class="tocitem" href>Blog</a><ul class="internal"><li><a class="tocitem" href="#"><span>2020</span></a></li><li><a class="tocitem" href="#-2"><span>2019</span></a></li></ul></li><li><a class="tocitem" href="../chapter1/">1 - The Application</a></li><li><span class="tocitem">Section 1 - Experimenting with Modules</span><ul><li><a class="tocitem" href="../chapter2/">2 - Setup the Development Environment</a></li><li><a class="tocitem" href="../chapter3/">3 - Create and Test Domain.jl</a></li><li><a class="tocitem" href="../chapter4/">4 - Create and Test API.jl</a></li><li><a class="tocitem" href="../chapter5/">5 - Create and Test Infrastructure.jl</a></li><li><a class="tocitem" href="../chapter6/">6 - The Accounts Package from a User Point of View</a></li><li><a class="tocitem" href="../chapter7/">7 - Documenting your module</a></li></ul></li><li><span class="tocitem">Section 2 -  The Accounts Receivable Module</span><ul><li><a class="tocitem" href="../chapter8/">8 - The Design</a></li><li><a class="tocitem" href="../chapter9/">9 - The Sub-Module Domain</a></li><li><a class="tocitem" href="../chapter10/">10 - The Sub-Module API</a></li><li><a class="tocitem" href="../chapter11/">11 - The Sub-Module Infrastructure</a></li><li><a class="tocitem" href="../chapter12/">12 - The Main-Module AppliAR.jl</a></li></ul></li><li><span class="tocitem">Section 3 - Using containers</span><ul><li><a class="tocitem" href="../chapter13/">13 - Creating SSH Enabled Containers</a></li><li><a class="tocitem" href="../chapter14/">14 - Run the Application in Containers</a></li><li><a class="tocitem" href="../chapter15/">15 - Running the Containers</a></li></ul></li><li><span class="tocitem">Section 4 - Miscelanious</span><ul><li><a class="tocitem" href="../chapter16/">16 - Logging</a></li><li><a class="tocitem" href="../chapter17/">17 - Implementing AppliAR (Accounts Receivable) Package</a></li><li><a class="tocitem" href="../chapter18/">18 - PosgreSQL</a></li></ul></li><li><a class="tocitem" href="../appendix/">Installation Instruction</a></li><li><a class="tocitem" href="../notebook/">IJulia Notebook</a></li><li><a class="tocitem" href="../overview/">Overview Julia</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Blog</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Blog</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/rbontekoe/BAWJ/blob/master/docs/src/blog.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Blog"><a class="docs-heading-anchor" href="#Blog">Blog</a><a id="Blog-1"></a><a class="docs-heading-anchor-permalink" href="#Blog" title="Permalink"></a></h1><h2 id><a class="docs-heading-anchor" href="#">2020</a><a id="-1"></a><a class="docs-heading-anchor-permalink" href="#" title="Permalink"></a></h2><h3 id="/09/2020-Solved-the-Triple-Back-Ticks-Problem"><a class="docs-heading-anchor" href="#/09/2020-Solved-the-Triple-Back-Ticks-Problem">09/09/2020 - Solved the Triple Back Ticks Problem</a><a id="/09/2020-Solved-the-Triple-Back-Ticks-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#/09/2020-Solved-the-Triple-Back-Ticks-Problem" title="Permalink"></a></h3><p>If you want to display (triple back ticks)[https://meta.stackexchange.com/questions/82718/how-do-i-escape-a-backtick-within-in-line-code-in-markdown] in a text block enclose it between four back ticks. I updated chapter 4.</p><p>I aecided to extend section 1 with a chapter about Documenter.jl the reason I searched again for a solution of the back ticks.</p><h3 id="/20/2020"><a class="docs-heading-anchor" href="#/20/2020">08/20/2020</a><a id="/20/2020-1"></a><a class="docs-heading-anchor-permalink" href="#/20/2020" title="Permalink"></a></h3><p>Finished section 1 <code>Experimenting with Modules</code>. Reviewed chapters one till six. I did the activities and exercises. Looks good.</p><p>The next step is section 2 <code>The Accounts Receivable Module</code>.</p><h3 id="/11/2020"><a class="docs-heading-anchor" href="#/11/2020">08/11/2020</a><a id="/11/2020-1"></a><a class="docs-heading-anchor-permalink" href="#/11/2020" title="Permalink"></a></h3><p>Today, I &#39;finished&#39; the Accounts.jl module. I am happy that I switched to an easier example of the activities and exercise.</p><h3 id="/03/2020"><a class="docs-heading-anchor" href="#/03/2020">08/03/2020</a><a id="/03/2020-1"></a><a class="docs-heading-anchor-permalink" href="#/03/2020" title="Permalink"></a></h3><p>Received my Samsung Portable SSD T5 and installed Ubuntu 20.04 on it. It is very fast.</p><p>I also rewrote the appendix with up-to-date installation instructions. I changed the name Appendix into Installation instructions. <a href="https://www.appligate.nl/BAWJ/dev/">See</a>.</p><h3 id="/15/2020-Rewrite-the-course"><a class="docs-heading-anchor" href="#/15/2020-Rewrite-the-course">07/15/2020 - Rewrite the course</a><a id="/15/2020-Rewrite-the-course-1"></a><a class="docs-heading-anchor-permalink" href="#/15/2020-Rewrite-the-course" title="Permalink"></a></h3><p>Added documentation to <a href="https://www.appligate.nl/AppliAR.jl/">AppliAR</a>. In <a href="https://www.appligate.nl/AppliAR.jl/chapter4/">4. Example</a> the code that uses Docker containers and actors. Now ready to rewrite the course and incorporate the actors.</p><h3 id="/10/2020-Rocket.jl"><a class="docs-heading-anchor" href="#/10/2020-Rocket.jl">07/10/2020 - Rocket.jl</a><a id="/10/2020-Rocket.jl-1"></a><a class="docs-heading-anchor-permalink" href="#/10/2020-Rocket.jl" title="Permalink"></a></h3><p>I played last week with Rocket.jl, a package where you can work with actors. During the time I worked with Akka and Scala, I became familiar with the idea of actors.</p><p>Actors send messages to other actors, which are stored in their mailbox and then processed one by one. The advantage is that the actors are completely separated from each other and can manage their data.</p><p>The results were positive, so I consider to set up the application the way I did with Akka.</p><h3 id="/25/2020-Domain,-API,-and-Infrastructure-as-sub-modules"><a class="docs-heading-anchor" href="#/25/2020-Domain,-API,-and-Infrastructure-as-sub-modules">06/25/2020 - Domain, API, and Infrastructure as sub-modules</a><a id="/25/2020-Domain,-API,-and-Infrastructure-as-sub-modules-1"></a><a class="docs-heading-anchor-permalink" href="#/25/2020-Domain,-API,-and-Infrastructure-as-sub-modules" title="Permalink"></a></h3><p>A sub-module is a defined unit where you define what the input is and what someone else can use. Would it have an advantage to define the Domain, API and Infrastructure shell as a sub module as well?  I implemented it in AppliAR.</p><h3 id="/11/2020-Registered-the-packages-AppliSales-and-AppliGeneralLedger"><a class="docs-heading-anchor" href="#/11/2020-Registered-the-packages-AppliSales-and-AppliGeneralLedger">05/11/2020 - Registered the packages AppliSales and AppliGeneralLedger</a><a id="/11/2020-Registered-the-packages-AppliSales-and-AppliGeneralLedger-1"></a><a class="docs-heading-anchor-permalink" href="#/11/2020-Registered-the-packages-AppliSales-and-AppliGeneralLedger" title="Permalink"></a></h3><p>Last Friday, I have registered my first packages at <a href="https://github.com/JuliaRegistries/General">JuliaRegistries/General</a>:</p><ul><li>AppliSales</li><li>AppliGeneralLedger</li></ul><p>To register the packages you use <a href="https://juliahub.com/ui/Home">https://juliahub.com/ui/Packages</a>, using the <code>Registering Packages</code> page. You have to wait for three days before you can add the packages to a project.</p><p>I had to do this because AppliSales and AppliGeneralLedgers are dependencies in AppliAR.jl and I wanted to make use of Travis CI. Travis CI requires that it can add the tests (in <code>runtests.jl</code>) from the official Julia registry.</p><p>Now I am considering to partially rewrite the course to incorporate my newly acquired knowledge.</p><h3 id="/07/2020-PkgTemplates.jl"><a class="docs-heading-anchor" href="#/07/2020-PkgTemplates.jl">05/07/2020 - PkgTemplates.jl</a><a id="/07/2020-PkgTemplates.jl-1"></a><a class="docs-heading-anchor-permalink" href="#/07/2020-PkgTemplates.jl" title="Permalink"></a></h3><p>After watching the video <a href="https://www.youtube.com/watch?reload=9&amp;v=QVmU29rCjaA">Developing Julia Packages</a> I decided to use <code>PkgTemplates.jl</code> as the starting point for package development.</p><p>I created the package AppliAR.jl (AR = Account Receivable) with the code from AppliInvoicing.jl, a name I will replace.</p><p>Also, I recreated the supporting packages AppliSales.jl and AppliGeneral.jl.</p><p>Overall, I believe that what I learned from using PkgTemplates makes the application more professional. Unfortunately, I have to rewrite parts of the course.</p><p>In <a href="https://github.com/rbontekoe/AppliMaster.jl">AppliMaster.jl</a> you find the files <code>test_local_channels_2.jl</code> and <code>client.jl</code> to test the application.</p><pre><code class="language-none"># test_local_channels2.jl

using Pkg
Pkg.activate(&quot;.&quot;)

# remove old stuff
cmd = `rm test_invoicing.sqlite test_ledger.txt test_journal.txt`
run(cmd)

# enable distrbuted computing
using Distributed
@info(&quot;Enable distributed computing&quot;)

# this should be the next step
np = addprocs(4; exeflags=`--project=$(Base.active_project())`)
#np = addprocs([(&quot;rob@192.168.2.77:2222&quot;, :auto)]; exeflags=`--project=$(Base.active_project())`)
@info(&quot;number of processes is $(length(np))&quot;)

# activate the packages (before the processes are created)
@everywhere begin
    using AppliSales
    using AppliGeneralLedger
    using AppliAR
end;

@info(&quot;Distributed computing enabled&quot;)

# get the tasks and dispatcher
include(&quot;./api/api.jl&quot;)

# start the dispatcher
rx = dispatcher()
@info(&quot;Dispatcher started&quot;)

# start application remote
include(&quot;client.jl&quot;)

# display aging report
using DataFrames

sleep(10)
r = DataFrame(report())
println(&quot;\nUnpaid invoices\n============&quot;)
println(r)
</code></pre><h3 id="/17/2010-Using-socket-for-remote-communication"><a class="docs-heading-anchor" href="#/17/2010-Using-socket-for-remote-communication">04/17/2010 - Using socket for remote communication</a><a id="/17/2010-Using-socket-for-remote-communication-1"></a><a class="docs-heading-anchor-permalink" href="#/17/2010-Using-socket-for-remote-communication" title="Permalink"></a></h3><p>I have defined Task_4 in <code>myfunctions2.jl</code> of AppliMaster. The task listens on port 8000. When data is detected, it is deserialized. The string START will initiate the process. Sending a <code>BankStatement</code> will create the paid invoices.</p><p>First start <code>test_local_channels_2.jl</code>. Then run the next code in a separate Julia session.</p><pre><code class="language-none">using Sockets
using Serialization
using AppliGeneralLedger, AppliInvoicing

io = connect(&quot;&lt;ip target laptop&gt;&quot;, 8000)

# start application
serialize(io, &quot;START&quot;)

# send bankstatements
stms = AppliInvoicing.read_bank_statements(&quot;./bank.csv&quot;)
serialize(io, stms)</code></pre><h3 id="/27/2020-Extending-Julia-LOAD_PATH"><a class="docs-heading-anchor" href="#/27/2020-Extending-Julia-LOAD_PATH">03/27/2020 - Extending Julia LOAD_PATH</a><a id="/27/2020-Extending-Julia-LOAD_PATH-1"></a><a class="docs-heading-anchor-permalink" href="#/27/2020-Extending-Julia-LOAD_PATH" title="Permalink"></a></h3><p>II wanted to add a new feature to AppliInvoicing: reporting e.g., an aging report. It should live in a submodule of AppliInvoicing. First, I created a branch <code>dev</code>:</p><pre><code class="language-none">$ git branch dev

$ git checkout dev

$ atom .</code></pre><p>Next, I created the file <code>Reporting.jl</code> and created a dummy module <code>Reporting</code>:</p><pre><code class="language-none">module Reporting

const PATH_DB = &quot;./invoicing.sqlite&quot;

using Dates

using AppliInvoicing

aging() = begin
    unpaid_invoices = AppliInvoicing.retrieve_unpaid_invoices(PATH_DB)
    list = []
    for invoice in unpaid_invoices
        date = invoice.meta.date
        println(date, &quot; - &quot;, Dates.today())
    end
end # aging

end # module</code></pre><p>After that, I added the function <code>report()</code> to <code>api.jl</code> and modified the file <code>AppliInvoicing.jl</code>:</p><pre><code class="language-none">module AppliInvoicing

greet() = print(&quot;Hello World!&quot;)

export create, process, retrieve_unpaid_invoices, read_bank_statements, report

# first, link to the current model
include(&quot;./infrastructure/infrastructure.jl&quot;)

# next, submodule Reporting
include(&quot;Reporting.jl&quot;)
using .Reporting: aging

end # module</code></pre><p>To test the module, I used <code>AppliMaster</code>. I didn&#39;t want all the time to upload <code>AppliInvoicing</code> to GitHub, so I extended the Julia <code>LOAD_PATH</code>. After removing the <code>AppliInvoicing</code> package, I added the next line to <code>test_local_channels.jl</code>:</p><pre><code class="language-none"># define the local path for AppliInvoicing
@everywhere push!(LOAD_PATH, &quot;/home/rob/julia-projects/tc/AppliInvoicing&quot;)</code></pre><h3 id="/25/2020-Holy-traits-pattern-implemented-in-dispatcher"><a class="docs-heading-anchor" href="#/25/2020-Holy-traits-pattern-implemented-in-dispatcher">03/25/2020 - Holy traits pattern implemented in dispatcher</a><a id="/25/2020-Holy-traits-pattern-implemented-in-dispatcher-1"></a><a class="docs-heading-anchor-permalink" href="#/25/2020-Holy-traits-pattern-implemented-in-dispatcher" title="Permalink"></a></h3><p>The <code>Holy traits pattern</code> is described in the book Design Patterns and Best Practices with Julia. It can replace if-else constructs. Old situation <a href="https://www.appligate.nl/BAWJ/chapter6/#The-dispatcher-1">dispatcher logic</a>. With the new situation, we avoid troubles in the future when we use more Appli-packages. See current infrastructure, <a href="https://www.appligate.nl/BAWJ/chapter6/">6. Testing the application</a>. The Holy traits pattern makes it more clear:</p><pre><code class="language-none"># Holy traits pattern definition =&gt; can be moved to the domain layer
abstract type Dispatcher end
struct T0 &lt;: Dispatcher end # AppliMaster
struct T1 &lt;: Dispatcher end # AppliInvoicing
struct T2 &lt;: Dispatcher end # AppliGeneralLedger
struct T3 &lt;: Dispatcher end # AppliInvoicing

# the data types on rx-channel
Dispatcher(::Type{&lt;: String}) = T0()
Dispatcher(::Type{&lt;: Array{AppliSales.Order, 1}}) = T1()
Dispatcher(::Type{&lt;: Array{AppliGeneralLedger.JournalEntry,1}}) = T2()
Dispatcher(::Type{&lt;: Array{AppliInvoicing.BankStatement,1}}) = T3()
# end Trait definition

function dispatcher()
    rx = Channel(32)

    # instantiate tasks
    tx0 = task_0(rx) # get orders from Sales
    tx1 = task_1(rx) # process the orders
    tx2 = task_2(rx) # process the journal entries
    tx3 = task_3(rx) # process the unpaid invoices

    # implementate Holy traits pattern
    dispatch(x::T) where {T} = dispatch(Dispatcher(T), x)

    dispatch(::T0, x) = put!(tx0, x)
    dispatch(::T1, x) = put!(tx1, x)
    dispatch(::T2, x) = put!(tx2, x)
    dispatch(::T3, x) = put!(tx3, x)

    @async while true
        if isready(rx)
            value = take!(rx)
            @info(&quot;Dispatcher received $(typeof(value))&quot;)
            dispatch(value)
        else
            wait(rx)
        end
    end

    return rx
end # dispatcher
</code></pre><h3 id="/20/2020-Design-Patterns-and-Best-Practices-with-Julia"><a class="docs-heading-anchor" href="#/20/2020-Design-Patterns-and-Best-Practices-with-Julia">03/20/2020 - Design Patterns and Best Practices with Julia</a><a id="/20/2020-Design-Patterns-and-Best-Practices-with-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#/20/2020-Design-Patterns-and-Best-Practices-with-Julia" title="Permalink"></a></h3><p>Recently I bought the book <a href="https://www.amazon.com/Hands-Design-Patterns-Julia-comprehensive/dp/183864881X">Design Patterns and Best Practices with Julia</a>. I can recommend the book. After reading the chapter <code>Modules, Packages, and Data Type Concepts</code>, I decided to set up an abstract data tree, because it can give you a quick overview of your application. The branches are the abstract data types and the leaves the concrete data types. I chose <code>Domain</code> as an abstract root type.</p><p>Using the function <code>subtypetree(Domain),</code> I get an excellent overview of the data structure:</p><pre><code class="language-none">julia&gt; subtypes(Invoice)
2-element Array{Any,1}:
 PaidInvoice  
 UnpaidInvoice

julia&gt; subtypetree(Domain)
Domain
    Invoice
        PaidInvoice
        UnpaidInvoice
    Payment
        BankStatement
    Structure
        BodyItem
            OpentrainingItem
        Header
        MetaInvoice

julia&gt; fieldnames(PaidInvoice)
(:id, :meta, :header, :body, :stm)

julia&gt; fieldnames(UnpaidInvoice)
(:id, :meta, :header, :body)</code></pre><p>See the <a href="https://www.appligate.nl/AppliInvoicing.jl/">Invoicing module</a> documentation for more details.</p><h3 id="/12/2020-Relative-mark-down-links"><a class="docs-heading-anchor" href="#/12/2020-Relative-mark-down-links">03/12/2020 - Relative mark down links</a><a id="/12/2020-Relative-mark-down-links-1"></a><a class="docs-heading-anchor-permalink" href="#/12/2020-Relative-mark-down-links" title="Permalink"></a></h3><p>Chapter 11 was not updated. I also got a message <code>Page build failure</code>.</p><p>The solution was to use relative links to switch between pages, e.g. <code>../chapter10/#.-Create-a-Dockerfile-in-the-folder-test_ssh-1</code>.</p><h3 id="/11/2020-Pages.jl-and-HTTP.jl"><a class="docs-heading-anchor" href="#/11/2020-Pages.jl-and-HTTP.jl">03/11/2020 - Pages.jl and HTTP.jl</a><a id="/11/2020-Pages.jl-and-HTTP.jl-1"></a><a class="docs-heading-anchor-permalink" href="#/11/2020-Pages.jl-and-HTTP.jl" title="Permalink"></a></h3><p>I did some tests with Pages.jl and HHTP.jl, The result is promising. The solution is to send a file name over an Http connection and use <code>scp</code> to retrieve the file from the Raspberry Pi for further processing.</p><h5 id="The-test"><a class="docs-heading-anchor" href="#The-test">The test</a><a id="The-test-1"></a><a class="docs-heading-anchor-permalink" href="#The-test" title="Permalink"></a></h5><p>Julia 1.3.1 running on my laptop in a Ubuntu docker container as server. The variable <code>result</code> will contain the file name:</p><pre><code class="language-none">julia&gt; using Pages

julia&gt; using JSON

julia&gt; @async Pages.start()
Task (runnable) @0x00007fb2c0ee3340

julia&gt; result = &quot;&quot;
&quot;&quot;

julia&gt; Endpoint(&quot;/test&quot;, POST) do request::HTTP.Request
           data = String(request.body)
           global result = data
           response = JSON.json(Dict(:data =&gt; data))
       end
Endpoint(Dict{Symbol,HTTP.Handlers.RequestHandlerFunction}(:POST =&gt; HTTP.Handlers.RequestHandlerFunction{var&quot;#11#12&quot;}(var&quot;#11#12&quot;())), &quot;/test&quot;)</code></pre><p>Julia 1.3.1 running on my Raspberry Pi in a Ubuntu docker container as client:</p><pre><code class="language-none">julia&gt; using HTTP

julia&gt; r = HTTP.request(&quot;POST&quot;, &quot;http://xxx.xxx.xxx.xxxxxxx:8000/test&quot;, [], &quot;12345.jpg&quot;)
HTTP.Messages.Response:
&quot;&quot;&quot;
HTTP/1.1 200 OK
Transfer-Encoding: chunked

{&quot;data&quot;:&quot;12345.jpg&quot;}&quot;&quot;&quot;</code></pre><h3 id="/10/2020-SQLite-problem-Raspberry-Pi"><a class="docs-heading-anchor" href="#/10/2020-SQLite-problem-Raspberry-Pi">03/10/2020 - SQLite problem Raspberry Pi</a><a id="/10/2020-SQLite-problem-Raspberry-Pi-1"></a><a class="docs-heading-anchor-permalink" href="#/10/2020-SQLite-problem-Raspberry-Pi" title="Permalink"></a></h3><p>There is a problem with making a connection from a docker container on my Ubuntu laptop to a container on a Raspberry Pi 3+. I posted a question on  <code>discourse.</code></p><p>See <a href="https://discourse.julialang.org/t/addprocs-gives-connection-refused-to-a-docker-container-on-raspberry-pi/35640">Addprocs gives connection refused to a docker container on raspberry pi</a></p><p>Now I consider using HTTP.jl (or Pages.jl) to inform the application to retrieve an image from my Raspi with scp.</p><h3 id="/04/2020-Documentation-AppliInvoicing-module"><a class="docs-heading-anchor" href="#/04/2020-Documentation-AppliInvoicing-module">03/04/2020 - Documentation AppliInvoicing module</a><a id="/04/2020-Documentation-AppliInvoicing-module-1"></a><a class="docs-heading-anchor-permalink" href="#/04/2020-Documentation-AppliInvoicing-module" title="Permalink"></a></h3><p>I have completed the documentation for <a href="https://www.appligate.nl/AppliInvoicing.jl/">ApplInvoicing.jl</a></p><h3 id="/03/2020-2"><a class="docs-heading-anchor" href="#/03/2020-2">03/03/2020</a><a class="docs-heading-anchor-permalink" href="#/03/2020-2" title="Permalink"></a></h3><p>Created documentation for the module <a href="https://www.appligate.nl/AppliGeneralLedger.jl/">AppliGeneralLedger</a>.</p><p>Master code runs successfully in a Docker container.</p><h3 id="/27/2020-dispatcher-is-working"><a class="docs-heading-anchor" href="#/27/2020-dispatcher-is-working">02/27/2020 - dispatcher is working</a><a id="/27/2020-dispatcher-is-working-1"></a><a class="docs-heading-anchor-permalink" href="#/27/2020-dispatcher-is-working" title="Permalink"></a></h3><p>SQLite gave problems with AppliGeneralLedger. I suspected it had something to do with multi-user issues. So I decided to experiment with Jula&#39;s open/read/write file functions.  The result was very positive, so I changed the code in AppliGeneralLedger.</p><p>The test with remote channels went well. AppliMaster contains the code.</p><h3 id="/20/2020-addproc(4)"><a class="docs-heading-anchor" href="#/20/2020-addproc(4)">02/20/2020 - addproc(4)</a><a id="/20/2020-addproc(4)-1"></a><a class="docs-heading-anchor-permalink" href="#/20/2020-addproc(4)" title="Permalink"></a></h3><p>In the past, I used Julia v1.1.0 and SQLite v0.8.x. I use a local channel with a dispatcher. It routes the data to the right task, which runs a Julia function remote. The application ran smoothly. The problem started when I switched to SQLite.jl v1.0.1. First, I thought that SQLite was causing the problem. However, the sample code uses only the AppliSales module, which doesn’t use SQLite.</p><p>I posted the problem on discourse.julialang.org: <a href="https://discourse.julialang.org/t/distributed-computing-not-found-package-error/34851">Distributed computing, not found package error</a>. @pfitzseb gave the solution:</p><p>Try</p><pre><code class="language-none">addprocs(n_procs; exeflags=`--project=$(Base.active_project())`)</code></pre><p>instead – the currently active environment doesn’t propagate to processes started by addprocs by default.</p><p>Now the application runs smoothly again. Thank you, `@pfitzseb.</p><h3 id="/07/2020"><a class="docs-heading-anchor" href="#/07/2020">02/07/2020</a><a id="/07/2020-1"></a><a class="docs-heading-anchor-permalink" href="#/07/2020" title="Permalink"></a></h3><p>Chapter 4, 5 en 6 are ready for a final check.</p><h3 id="/05/2020"><a class="docs-heading-anchor" href="#/05/2020">02/05/2020</a><a id="/05/2020-1"></a><a class="docs-heading-anchor-permalink" href="#/05/2020" title="Permalink"></a></h3><p>While working on the AppliMaster module, I got yesterday the impression that I should always be working with the local package repository, <code>] active .</code>:</p><ul><li><p>Adding packages will update <code>Project.toml</code>, the file with the dependencies, and update the local Manifest.toml file. When you delete Manifest.toml, you have to add the packages again.</p></li><li><p>When cloning a project works without adding the packages again.</p></li></ul><p>So I removed AppliInvoicing, AppliGeneralLedger, and AppliSales from the general repository. This morning I started AppliMaster in Atom. My code in <code>test_remote_channels.jl</code> didn&#39;t work anymore. The two Databases invoicing.sqlite and <code>ledger.sqlite</code> were not created.</p><p>I added the packages AppliInvoicing, AppliGeneralLedger, and AppliSales again to the general repository, and my code was running well. The only explanation I could think of: remote code only looks at the general repository.</p><p>I need to review the documentation on this subject.</p><h3 id="/02/2020"><a class="docs-heading-anchor" href="#/02/2020">02/02/2020</a><a id="/02/2020-1"></a><a class="docs-heading-anchor-permalink" href="#/02/2020" title="Permalink"></a></h3><p>The pages <code>test_remote_channels.jl</code> and <code>myfunctions.jl</code>, I have embellished with <code>@info</code>. The flow of the data has now become more explicit. The code is on github: <a href="https://github.com/rbontekoe/AppliMaster.jl/blob/master/src/test_remote_channels.jl">test_remote_channels.jl</a>.</p><p>Working with channels runs smoothly. I only run the functions that perform the operations on a different core. The <code>while true</code> loops for <code>task_1</code> and <code>task_2</code> tasks run locally. Should I also run these loops remotely?</p><p>So I had to renumber the subsequent chapters.</p><h3 id="/01/2020"><a class="docs-heading-anchor" href="#/01/2020">02/01/2020</a><a id="/01/2020-1"></a><a class="docs-heading-anchor-permalink" href="#/01/2020" title="Permalink"></a></h3><p>Today I copied the blog from the AppliGate website to The course environment.</p><p>Things are going well with the course. The following modules are now ready(!):</p><ul><li>AppliMaster - the basic module.</li><li>AppliInvoicing - the application itself.</li><li>AppliSales - sending test orders to AppliInvoicing.</li><li>AppliGeneralLedger - to process journal entries from AppliInvoicing.</li></ul><p>In the last couple of weeks, I have been experimenting with the communication between the different parts. For the time being, I decided to work with Julia&#39;s channels. The implementation is in AppliMaster, <a href="https://github.com/rbontekoe/AppliMaster.jl/blob/master/src/test_remote_channels.jl">test<em>remote</em>channels.jl</a>.</p><h2 id="-2"><a class="docs-heading-anchor" href="#-2">2019</a><a class="docs-heading-anchor-permalink" href="#-2" title="Permalink"></a></h2><h3 id="/05/2019"><a class="docs-heading-anchor" href="#/05/2019">12/05/2019</a><a id="/05/2019-1"></a><a class="docs-heading-anchor-permalink" href="#/05/2019" title="Permalink"></a></h3><p>Last week I managed to establish an SSH connection between two containers. This week I could finish <a href="https://www.appligate.nl/BAWJ/chapter9/">Chapter 9</a>, <code>Create the Container</code>, more or less. The next step is to test a channel connection between two containers.</p><h3 id="/15/2019"><a class="docs-heading-anchor" href="#/15/2019">11/15/2019</a><a id="/15/2019-1"></a><a class="docs-heading-anchor-permalink" href="#/15/2019" title="Permalink"></a></h3><p>Almost ready to link www.appligate.nl to rbontekoe.github.io. We have to change the CNAME record at the provider from <a href="http://appligate.appspot.com/">appligate.appspot.com</a> to <a href="https://rbontekoe.github.io/">rbontekoe.github.io</a>.</p><p>We also started with writing the course material for the online training <a href="https://rbontekoe.github.io/BAWJ/">BAWJ</a>.</p><h3 id="/21/2019"><a class="docs-heading-anchor" href="#/21/2019">10/21/2019</a><a id="/21/2019-1"></a><a class="docs-heading-anchor-permalink" href="#/21/2019" title="Permalink"></a></h3><p>Why not build a website with Documenter.jl? We did it today. When you go to <a href="https://rbontekoe.github.io">AppliGate</a>, you enter our new site. In the meantime, we got more experience with Julia. E.g., we resized Rob&#39;s picture with Images.jl. It was straightforward.</p><pre><code class="language-julia">julia&gt; using Images

julia&gt; img = load(&quot;rob.png&quot;)

julia&gt; img2 = imresize(img, ratio=0.5)

julia&gt; save(&quot;rob2.png&quot;, img2)</code></pre><h3 id="/17/2019"><a class="docs-heading-anchor" href="#/17/2019">9/17/2019</a><a id="/17/2019-1"></a><a class="docs-heading-anchor-permalink" href="#/17/2019" title="Permalink"></a></h3><p>Reading Think Julia I discovered the package Serialization. While playing with it, I realized that it could solve my CQRS and Event Sourcing problem. With the method serialize, you can create a text representation of an object, that you can store. With deserialize, you do the reverse. Serialize writes to an IOStream, and deserialize reads from it. An IOStream can be an IOBuffer or a file. It makes Event Sourcing easier.</p><p>I also looked at channels. You can use channels to communicate between processes. For the time being, I will use inter CPU-core communication. Later on, I extend it to remote nodes. I only have to expand the methods of createSubscriber and createPublisher.</p><h3 id="/10/2019"><a class="docs-heading-anchor" href="#/10/2019">9/10/2019</a><a id="/10/2019-1"></a><a class="docs-heading-anchor-permalink" href="#/10/2019" title="Permalink"></a></h3><p>Last week I was busy implementing the database methods. I realized that the domain objects I wanted to keep must have an identification code. So Subscriber, Publisher, and Message got an id. To create the id, I used the hash function with a name and time as a parameter. It had consequences for the documentation. In the example code, I used the tag &#39;jldoctest,&#39; so Documenter could test the example code during the generation of the manual. Because the ids keep changing, I had to give up. Too bad, because I found that a strong point of Documenter.jl. I replaced the test tag &#39;jldoctest&#39; with the language tag &#39;julia.&#39; Maybe there is something to do against continually changing values.</p><p>Infected by the CQRS thought, I decided to add changed domain objects to the database instead of modifying an existing record.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Business Applications with Julia</a><a class="docs-footer-nextpage" href="../chapter1/">1 - The Application »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 12 October 2020 23:26">Monday 12 October 2020</span>. Using Julia version 1.5.0-rc2.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
